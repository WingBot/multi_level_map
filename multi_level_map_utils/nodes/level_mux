#!/usr/bin/env python

from geometry_msgs.msg import PoseWithCovarianceStamped
from multi_level_map_msgs.msg import LevelMetaData, MultiLevelMapData
from multi_level_map_msgs.srv import ChangeCurrentLevel, ChangeCurrentLevelRequest
import multi_level_map_utils.utils as utils
from nav_msgs.msg import MapMetaData, OccupancyGrid
from nav_msgs.srv import GetMap
import rospy
import tf

class LevelMultiplexer:

    def __init__(self):

        rospy.init_node("map_mux")

        # Subcribe to the multi level map data to get information about all the maps.
        self.multimap_subscriber = rospy.Subscriber("map_metadata", MultiLevelMapData, self.process_multimap)
        self.multimap_available = False
        self.levels = []

        # We also need to publish information about the current level.
        self.current_level = None
        self.status_publisher = rospy.Publisher("~current_level", LevelMetaData, latch=True)

        # Based on the current level id, publish map, static_map, map_metadata and initial_pose (i.e. the mux output).
        self.level_publisher = None
        self.level_metadata_publisher = None
        self.level_map_service = None
        self.initialpose_publisher = None

        # Finally, provide a service that allows the current level to be changed.
        # This service will get enabled once the multimap becomes available.
        self.change_level_service = None

    def process_multimap(self, msg):

        # Get information about all the levels.
        self.multimap_available = True
        self.levels = msg.levels

        # If the service to change the level hasn't been advertised, then advertise it now.
        if self.change_level_service is None:
            self.change_level_service = rospy.Service('~change_current_level', ChangeCurrentLevel, self.change_level)

        # Perform some sanity checks on the current_level
        if len(self.levels) == 1:
            # If there is only one level, then change to that level without publishing initialpose.
            req = ChangeCurrentLevelRequest()
            req.new_level_id = self.levels[0].level_id
            req.publish_initial_pose = False
            self.change_level(req)
        elif self.current_level is not None:
            # This can only happen when the multimap changes from what it was previously. I'm not really sure if this
            # will ever be possible, but let's perform some sanity checks here to make sure we don't get screwed.
            current_level_found = False
            for level in self.levels:
                if self.current_level == level.level_id:
                    current_level_found = True
                    break
            if not current_level_found:
                # Of no! The multimap changed, and our current level is not longer available. Unregister everything!
                rospy.logerr("The multimap changed, and our selected current level " + self.current_level + " is no longer available. Navigation will probably not work properly!")
                if self.level_publisher is not None:
                    self.level_publisher.unregister()
                    self.level_publisher = None
                    self.level_metadata_publisher.unregister()
                    self.level_publisher = None
                    self.level_map_service.unregister()
                    self.level_map_service = None
                    self.initialpose_publisher.unregister()
                    self.initialpose_publisher = None
                self.current_level = None

    def get_single_message(self, topic, Msg):
        self.single_message = None
        temp_subscriber = rospy.Subscriber(topic, Msg, self.process_single_message)
        r = rospy.Rate(100)
        while not rospy.is_shutdown() and self.single_message is None:
            r.sleep()
        temp_subscriber.unregister()
        if self.single_message is None:
            # We are shutting down the node, just return an empty message.
            return Msg()
        return self.single_message

    def process_single_message(self, msg): 
        self.single_message = msg

    def change_level(self, req):
        success = True
        error_message = ""

        level_found = False
        available_level_names = []

        for level in self.levels:
            if level.level_id == req.new_level_id:

                # Make this the current level
                self.current_level = level.level_id

                # Initialize the mux output channels if they have not been initialized.
                if self.level_publisher is None:
                    self.level_publisher = rospy.Publisher("~map", OccupancyGrid, latch=True)
                    self.level_metadata_publisher = rospy.Publisher("~map_metadata", MapMetaData, latch=True)
                    self.level_map_service = rospy.Service('~static_map', GetMap, self.process_level_service)
                    # Note that initialpose is not latched, as the publication is only valid when the 
                    # change_current_level service is called. Soon after, the robot may have moved, and this estimate
                    # is incorrect.
                    self.initialpose_publisher = rospy.Publisher("initialpose", PoseWithCovarianceStamped) 

                # Publish everything!
                self.level_publisher.publish(self.get_single_message(utils.mapTopicFromLevelId(level.level_id),
                                                                     OccupancyGrid))
                self.level_metadata_publisher.publish(self.get_single_message(utils.metadataTopicFromLevelId(level.level_id),
                                                                              MapMetaData))
                if req.publish_initial_pose:
                    self.initialpose_publisher.publish(req.initial_pose)
                self.status_publisher.publish(level)

                level_found = True
                break
            else:
                available_level_names.append(level.level_id)

        if not level_found:
            success = False
            error_message = "Level " + req.new_level_id + " not found in available levels " + str(available_level_names)

        return success, error_message

    def process_level_service(self, req):
        level_service_proxy = rospy.ServiceProxy(utils.mapServiceFromLevelId(self.current_level), GetMap)
        return level_service_proxy()

    def spin(self):
        br = tf.TransformBroadcaster()
        r = rospy.Rate(1)
        while not rospy.is_shutdown():
            if self.current_level is not None:
                br.sendTransform((0, 0, 0),
                                 tf.transformations.quaternion_from_euler(0, 0, 0),
                                 rospy.Time.now(),
                                 'level_mux/map',
                                 utils.frameIdFromLevelId(self.current_level))
            r.sleep()

if __name__ == '__main__':
    level_mux = LevelMultiplexer()
    try:
        level_mux.spin()
    except rospy.ROSInterruptException: 
        pass
